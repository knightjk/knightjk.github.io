<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[errno与多线程变量安全]]></title>
    <url>%2F2018%2F12%2F17%2Flinux%2Ferrno-and-mult-thread-safety%2F</url>
    <content type="text"><![CDATA[errno作用 errno的功能 先man一下：1234The value in errno is significant only when the return value of the call indicated an error (i.e., -1 from most system calls; -1 or NULL from most library functions); a function that succeeds is allowed to change errno. The value of errno is never set to zero by any system call or library function.For some system calls and library functions (e.g., getpriority(2)), -1 is a valid return on success. In such cases, a successful return can be distinguished from an error return by setting errno to zero before the call, and then, if the call returns a status that indicates that an error may have occurred, checking to see if errno has a nonzero value.errno is defined by the ISO C standard to be a modifiable lvalue of type int, and must not be explicitly declared; errno may be a macro. errno is thread-local; setting it in one thread does not affect its value in any other thread. 就是说errno: 用于提示API的具体出错信息。linux的API返回出错都是非0值，但更具体的定位出错需要errno值来辅助定位。 errno一般不会被置0，然后只有API出错返回时errno才被设置，此时查询errno才有意义。 errno可能是一个宏，被定义为线程局部的,即errno能够符合线程安全。 errno的值定义 errno的具体指定义在sysdeps/mach/hurd/bits/errno.h文件中，有些长，这里先不列出来可以通过gcc官网git找到对应的定义 全局变量在多线程的风险 已知 errno在使用时需要通过 extern int errno声明为全局量定义，那么在多线程情况下是怎样呢，已知全局量在运行内存中是存放在数据段中，而多线程只有占用各自的小部分栈段和CPU寄存器资源，其他资源是共享的，那么如果 errno定义为普通的全局量，那么在多线程中共用的全局量在线程各自改变时肯定会受影响，譬如，线程1和线程2同时操作出错，但由于errno是全局量，有可能线程1捕获到的出错返回errno的信息实际上是线程2的报错信息，这样定义errno是不科学的。伟大的gnu必然会考虑这种情况，所以把errno定义为线程安全性的。那么 errno如何实现线程安全，下面继续深入了解errno实现。 errno深入探索实现机制 先查libc的源码，先用source insight查看extern int errno 关键字，可以找到如下的errno的可能的宏定义：1234#/*sysdeps/unix/sysv/linux/riscv/sysdep.S*/#if IS_IN (libc)# define errno __libc_errno#endif 1234/*errno.h(stdlib)*//* The error code set by various library functions. */extern int *__errno_location (void) __THROW __attribute_const__;# define errno (*__errno_location ()) 123/*errno.h(include)*/static int rtld_errno;# define errno rtld_errno 12/*errno.c(csu)*/__thread int errno; 那么，到底哪个是可能的errno的具体实现定义？这需要看程序中用到的errno的宏展开情况，编写以下测试代码：12345678910//errno_test.c#include &lt;errno.h&gt;extern int errno;int main(int argc, char* argv[])&#123; return 1;&#125; 然后只进行宏展开，不编译：1gcc -E errno_test.c 生成的结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 1 "errno_test.c"# 1 "&lt;built-in&gt;"# 1 "&lt;command-line&gt;"# 1 "/usr/include/stdc-predef.h" 1 3 4# 1 "&lt;command-line&gt;" 2# 1 "errno_test.c"# 1 "/usr/include/errno.h" 1 3 4# 28 "/usr/include/errno.h" 3 4# 1 "/usr/include/features.h" 1 3 4# 367 "/usr/include/features.h" 3 4# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4# 410 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4# 411 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4# 368 "/usr/include/features.h" 2 3 4# 391 "/usr/include/features.h" 3 4# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4# 392 "/usr/include/features.h" 2 3 4# 29 "/usr/include/errno.h" 2 3 4# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4# 1 "/usr/include/linux/errno.h" 1 3 4# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4# 1 "/usr/include/asm-generic/errno.h" 1 3 4# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4# 5 "/usr/include/asm-generic/errno.h" 2 3 4# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4# 1 "/usr/include/linux/errno.h" 2 3 4# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));# 36 "/usr/include/errno.h" 2 3 4# 58 "/usr/include/errno.h" 3 4# 3 "errno_test.c" 2# 5 "errno_test.c"extern int# 5 "errno_test.c" 3 4 (*__errno_location ())# 5 "errno_test.c" ;int main(int argc, char* argv[])&#123; return 1;&#125; 也就是说，extern int errno 中的errno被展开成 (*errno_location ())，再深入探索errno_location的定义:123/* The error code set by various library functions. */extern int *__errno_location (void) __THROW __attribute_const__;# define errno (*__errno_location ()) 往下追踪发现有两个定义，一个弱引用函数一个普通全局函数，先看弱引用函数定义：1234567891011121314151617#if IS_IN (rtld)/*sysdeps/mach/hurd/Errno-loc.c*//* rtld can not access TLS too early, thus rtld_errno. Instead of making __open/__close pass errno from TLS to rtld_errno, simply use a weak __errno_location using rtld_errno, which will be overriden by the libc definition. */static int rtld_errno;int * weak_function__errno_location (void)&#123; return &amp;rtld_errno;&#125;libc_hidden_weak (__errno_location)#else#include "../../../csu/errno-loc.c"#endif 这里说明libc的 __errno_location函数被定义时会使用libc的而忽略弱引用的函数，弱引用先返回的是rtld_errno这个静态量的地址。再来看看普通的__errno_location函数定义：123456/*Errno-loc.c(csu)*/int *__errno_location (void)&#123; return &amp;errno;&#125; 也就是说，最后返回的还是errno，那么这个errno到底是什么量？先用排除法排除以上的宏定义，得到errno可能是如下定义：12/*errno.c(csu)*/__thread int errno; 这个errno在定义时加上了一个 __thread，这个thread是什么？这个是线程局部存储的关键字，而且这个关键字需要编译器作为支撑的，这里是gcc.gnu对thread关键字的说明:12345678910111213141516Thread-local storage (TLS) is a mechanism by which variables are allocated such that there is one instance of the variable per extant thread. The run-time model GCC uses to implement this originates in the IA-64 processor-specific ABI, but has since been migrated to other processors as well. It requires significant support from the linker (ld), dynamic linker (ld.so), and system libraries (libc.so and libpthread.so), so it is not available everywhere.At the user level, the extension is visible with a new storage class keyword: __thread. For example: __thread int i; extern __thread struct state s; static __thread char *p;The __thread specifier may be used alone, with the extern or static specifiers, but with no other storage class specifier. When used with extern or static, __thread must appear immediately after the other storage class specifier.The __thread specifier may be applied to any global, file-scoped static, function-scoped static, or static data member of a class. It may not be applied to block-scoped automatic or non-static data member.When the address-of operator is applied to a thread-local variable, it is evaluated at run-time and returns the address of the current thread&apos;s instance of that variable. An address so obtained may be used by any thread. When a thread terminates, any pointers to thread-local variables in that thread become invalid.No static initialization may refer to the address of a thread-local variable.In C++, if an initializer is present for a thread-local variable, it must be a constant-expression, as defined in 5.19.2 of the ANSI/ISO C++ standard. 也就是说，对于__thread关键字： 使被修饰的变量在每个现存的线程有各自的一个变量实例 一开始gcc用于IA-64处理器，后面其他处理器也有，但不能保证所有处理器和编译其可用 可以单独使用，与外部或静态说明符一起使用，但不与其他存储类说明符一起使用。它可能不适用于块作用域的自动或非静态数据成员。 当线程终止时，该线程中任何指向线程本地变量的指针都将无效。 更深入的线程本地存储可以看(鄙人还没有看过的)这篇文章。 __thread的使用 从深入探索errno可以学到了thread定义的变量是线程安全的，那么把thread放在我们自己程序中来试验下是否真的是这样，首选，编写一段测试程序：头文件：12345678910111213141516//dynamic_link_variable.h#ifndef __DYNAMIC_LINK_VARIABLE_H__#define __DYNAMIC_LINK_VARIABLE_H__#include &lt;stdio.h&gt;typedef struct&#123; int* data_point; size_t size;&#125;data_area_t;int create_point(size_t size); //用于创建data_area_t结构体节点int modified_datas(int* data, size_t size); //用于更改数据void echo_datas(pthread_t pthread); //用于打印数据int delete_point(void); //用于删除节点#endif 目标使用程序如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//call_dynamic_link.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;stdint.h&gt;#include "dynamic_link_variable.h"//gcc call_dynamic_link.c -m32 -g -o call_dynamic -pthread -ldynamic -L. -Wl,-rpath,./void * test_thread1(void *arg)&#123; int data[12]; sleep(2); memset(data,0x22,sizeof(data)); create_point(24); printf("after thread1 create datas:\n"); echo_datas(pthread_self()); modified_datas(data, sizeof(data)/sizeof(data[0])); printf("after thread1 modified datas:\n"); echo_datas(pthread_self()); return NULL;&#125;void * test_thread2(void *arg)&#123; int data[12]; sleep(1); memset(data,0x33,sizeof(data)); create_point(24); printf("after thread2 create datas:\n"); echo_datas(pthread_self()); modified_datas(data, sizeof(data)/sizeof(data[0])); printf("after thread2 modified datas:\n"); echo_datas(pthread_self()); /*需要以下延迟来延长thread2的生存周期，否则如果thread2比thread1先退出， 根据这个程序条件那么thread1将会利用thread2使用过的空间,也就是说， 如果thread1和thread2有先后运行完成的关系，就会导致thread1和thread2开辟的同一段地址的空间 这是free函数的机制，free并不真正把空间释放，之前的空间仍然有保留*/ sleep(2); echo_datas(pthread_self()); return NULL;&#125;int main(int argc, char* argv[])&#123; pthread_t thread1; pthread_t thread2; int data[12]; memset(data,0x44,sizeof(data)); create_point(24); echo_datas(pthread_self()); modified_datas(data, sizeof(data)/sizeof(data[0])); //create thread1 printf("thread1 = 0x%x\n",(uint32_t)thread1); pthread_create(&amp;thread1, NULL, test_thread1, NULL); //create thread2 printf("thread2 = 0x%x\n",(uint32_t)thread2); pthread_create(&amp;thread2, NULL, test_thread2, NULL); //thread join pthread_join(thread1, (void**)&amp;data); //thread join pthread_join(thread2, (void**)&amp;data); return 1;&#125; 就是在创建两个线程之前主线程先改变和打印设置的量，然后线程thread2先再次创建和改变打印设置的量，中间停顿2s，在此期间thread1创建并改变和打印设置的量，然后thread1结束，thread2停顿2s后再次打印，具体的打印都会把设置量的值和地址体现出来。接下来先再证实一下普通全局变量在多线程的使用情况，以下是变量的定义文件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//dynamic_link_variable.c//test normal global data#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;pthread.h&gt;#include "dynamic_link_variable.h"//gcc dynamic_link_variable.c -m32 -g -fPIC -shared -o libdynamic.so -pthreaddata_area_t global_data = &#123;.data_point = NULL, .size = 0&#125;;int create_point(size_t size)&#123; if(global_data.data_point != NULL) return 1; global_data.data_point = (int *)malloc(sizeof(int)*size); if(global_data.data_point == NULL) &#123; return -1; &#125; global_data.size = size; return 0;&#125;int modified_datas(int* data, size_t size)&#123; if(size &gt; global_data.size) return -1; printf("modified data address is 0x%x\n",(uint32_t)&amp;global_data); memcpy(global_data.data_point, data, size*(sizeof(int))); return 0;&#125;void echo_datas(pthread_t pthread)&#123; int i = 0; //打印线程ID和变量的地址 printf("pthread = 0x%x, echo data address is 0x%x, size is 0x%x\n",(uint32_t)pthread,(uint32_t)&amp;global_data,global_data.size); for(i = 0;i &lt; global_data.size; i++) &#123; printf("0x%x ",global_data.data_point[i]); &#125; printf("\n");&#125;int delete_point(void)&#123; if(global_data.data_point != NULL) free(global_data.data_point); global_data.size = 0; global_data.data_point = NULL; return 0;&#125; 编译12gcc dynamic_link_variable.c -m32 -g -fPIC -shared -o libdynamic.so -pthread #生成libdynamic.sogcc call_dynamic_link.c -m32 -g -o call_dynamic -pthread -ldynamic -L. -Wl,-rpath,./ 运行12345678910111213141516171819202122seeing-zynq@seeing:thread_variable$ ./call_dynamicpthread = 0xf7d51700, echo data address is 0xf7f43028, size is 0x180x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0modified data address is 0xf7f43028thread1 = 0x2fthread2 = 0xf7d5fdc8after thread2 create datas:pthread = 0xf754fb40, echo data address is 0xf7f43028, size is 0x180x44444444 0x44444444 0x44444444 0x44444444 0x44444444 0x44444444 0x44444444 0x44444444 0x44444444 0x44444444 0x44444444 0x44444444 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0modified data address is 0xf7f43028after thread2 modified datas:pthread = 0xf754fb40, echo data address is 0xf7f43028, size is 0x180x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0after thread1 create datas:pthread = 0xf7d50b40, echo data address is 0xf7f43028, size is 0x180x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0modified data address is 0xf7f43028after thread1 modified datas:pthread = 0xf7d50b40, echo data address is 0xf7f43028, size is 0x180x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0pthread = 0xf754fb40, echo data address is 0xf7f43028, size is 0x180x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 结果显示普通全局量 global_data的地址在多线程打印出来是一个地址（都为0xf7f43028），由此可见普通全局变量在多线程是不安全的，这个在上面有提到，初始化的全局变量在初始化的数据段中，然鹅多线程会共用这个初始化的数据段。那么只将全局量用 __thread修饰后会怎样，只更改的上述代码，将global_data在定义时用 __thread修饰：1__thread data_area_t global_data = &#123;.data_point = NULL, .size = 0&#125;; 然后编译1gcc dynamic_link_variable.c -m32 -g -fPIC -shared -o libdynamic.so -pthread #生成libdynamic.so 运行12345678910111213141516171819202122seeing-zynq@seeing:thread_variable$ ./call_dynamicpthread = 0xf7d3a700, echo data address is 0xf7d3a6f8, size is 0x180x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0modified data address is 0xf7d3a6f8thread1 = 0x2fthread2 = 0xf7d48dc8after thread2 create datas:pthread = 0xf7538b40, echo data address is 0xf7538b38, size is 0x180x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0modified data address is 0xf7538b38after thread2 modified datas:pthread = 0xf7538b40, echo data address is 0xf7538b38, size is 0x180x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0after thread1 create datas:pthread = 0xf7d39b40, echo data address is 0xf7d39b38, size is 0x180x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0modified data address is 0xf7d39b38after thread1 modified datas:pthread = 0xf7d39b40, echo data address is 0xf7d39b38, size is 0x180x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0pthread = 0xf7538b40, echo data address is 0xf7538b38, size is 0x180x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 结果显示，在不同线程中global_data的存放地址是不同的，主线程的global_data地址在0xf7d3a6f8，线程1的global_data地址在0xf7d39b38，线程2的global_data地址在0xf7538b38。从这里可以看出，__thread关键字为每个线程开辟的global_data的地址是不同的。那么此时的global_data还是我们所谓的全局量吗？它存放的位置在哪里，是仍然存放在初始化的数据段，还是放在堆、栈或者其他什么地方呢？可以通过readelf命令查看global_data的信息。命令：1readelf -a libdynamic.so 先看没有__thread修饰的情况，打印太多，只看需要看的部分12345Symbol table &apos;.symtab&apos; contains 72 entries: Num: Value Size Type Bind Vis Ndx Name ..... 59: 00002028 8 OBJECT GLOBAL DEFAULT 24 global_data ..... 可见在没有thread修饰情况下，global_data为OBJECT类型，放置在全局。然后再看有thread修饰的情况：12345Symbol table &apos;.symtab&apos; contains 72 entries: Num: Value Size Type Bind Vis Ndx Name ..... 61: 00000000 8 TLS GLOBAL DEFAULT 17 global_data ..... 也就是说在thread修饰后，该变量仍然是全局性的，这说明thread并不改变变量的存放位置，只是把类型声明为TLS类型。 另一种方法实现变量线程安全 其实就是以下4个函数，利用key值来锁定分配的内存的位置信息，然后达到各个线程通过访问pthread_getspecific函数的方式来间接对堆的各个不同空间进行访问。 1234567int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *));int pthread_key_delete(pthread_key_t key);int pthread_setspecific(pthread_key_t key, const void *pointer);void * pthread_getspecific(pthread_key_t key); man手册上有一个简单的使用栗子（在此之前，可能需要安装一下pthread的man手册，在ubuntu上用sudo apt-get install glibc-doc和sudo apt-get install manpages-posix manpages-posix-devl来安装关于pthread的man手册）：123456789101112131415161718192021222324252627282930/* Key for the thread-specific buffer */static pthread_key_t buffer_key;/* Once-only initialisation of the key */static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;/* Allocate the thread-specific buffer */void buffer_alloc(void)&#123; pthread_once(&amp;buffer_key_once, buffer_key_alloc); pthread_setspecific(buffer_key, malloc(100));&#125;/* Return the thread-specific buffer */char * get_buffer(void)&#123; return (char *) pthread_getspecific(buffer_key);&#125;/* Allocate the key */static void buffer_key_alloc()&#123; pthread_key_create(&amp;buffer_key, buffer_destroy);&#125;/* Free the thread-specific buffer */static void buffer_destroy(void * buf)&#123; free(buf);&#125; 当然在这个过程中还需要利用pthread_once函数来锁定全局的key只用初始化一次。接下来编写上述生成libdynamic.so的另一个实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//dynamic_link_variable2.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;pthread.h&gt;#include "dynamic_link_variable.h"//gcc dynamic_link_variable2.c -m32 -g -fPIC -shared -o libdynamic.so -pthread/* Key for the thread-specific buffer */static pthread_key_t buffer_key;/* Once-only initialisation of the key */static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;/* Free the thread-specific buffer */static void buffer_destroy(void * buf)&#123; data_area_t* data_area = (data_area_t*)buf; free(data_area-&gt;data_point); free(data_area);&#125;/* Allocate the key */static void buffer_key_alloc()&#123; pthread_key_create(&amp;buffer_key, buffer_destroy); printf("--------------once process--------------\n");&#125;/* Allocate the thread-specific buffer */int buffer_alloc(size_t size)&#123; data_area_t* data_area; pthread_once(&amp;buffer_key_once, buffer_key_alloc); //only execute once data_area = (data_area_t*)malloc(sizeof(data_area_t)); if(data_area == NULL) return -1; data_area-&gt;data_point = (int* )malloc(sizeof(int) * size); if(data_area-&gt;data_point == NULL) &#123; free(data_area); return -2; &#125; data_area-&gt;size = size; pthread_setspecific(buffer_key, data_area); return 0;&#125;int create_point(size_t size)&#123; return buffer_alloc(size);&#125;int modified_datas(int* data, size_t size)&#123; data_area_t* data_area = (data_area_t* )pthread_getspecific(buffer_key); if(data_area == NULL) return -1; if(size &gt; data_area-&gt;size) return -2; printf("modified data address is 0x%x\n",(uint32_t)data_area); memcpy(data_area-&gt;data_point, data, size*(sizeof(int))); return 0;&#125;void echo_datas(pthread_t pthread)&#123; int i = 0; data_area_t* data_area = (data_area_t* )pthread_getspecific(buffer_key); if(data_area == NULL) return ; printf("pthread = 0x%x, echo data address is 0x%x,size is 0x%x\n",(uint32_t)pthread, (uint32_t)data_area,data_area-&gt;size); for(i = 0;i &lt; data_area-&gt;size; i++) &#123; printf("0x%x ",data_area-&gt;data_point[i]); &#125; printf("\n");&#125;int delete_point(void)&#123; return 0;&#125; 编译：1gcc dynamic_link_variable2.c -m32 -g -fPIC -shared -o libdynamic.so -pthread 同样运行call_dynamic：1234567891011121314151617181920212223seeing-zynq@seeing:thread_variable$ ./call_dynamic--------------once process--------------pthread = 0xf7cfe700, echo data address is 0x81d1410,size is 0x180x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0modified data address is 0x81d1410thread1 = 0x2fthread2 = 0xf7d0cdc8after thread2 create datas:pthread = 0xf74fcb40, echo data address is 0xf6b00470,size is 0x180x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0modified data address is 0xf6b00470after thread2 modified datas:pthread = 0xf74fcb40, echo data address is 0xf6b00470,size is 0x180x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0after thread1 create datas:pthread = 0xf7cfdb40, echo data address is 0xf6900470,size is 0x180x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0modified data address is 0xf6900470after thread1 modified datas:pthread = 0xf7cfdb40, echo data address is 0xf6900470,size is 0x180x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x22222222 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0pthread = 0xf74fcb40, echo data address is 0xf6b00470,size is 0x180x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x33333333 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 实现的效果与__thread的修饰符差不多，但是，通过pthread_setspecific系列函数是用于定义指针指向对于的内存空间的一个“别名”，然后在各个线程中各自指定使用。 疑问 __thread到底在gcc内部如何实现变量的线程安全? pthread_setspecific系列函数如何实现在各个不同线程的键(key)-值对应机制？ 参考 https://gcc.gnu.org/onlinedocs/gcc-3.4.6/gcc/Thread_002dLocal.html https://blog.csdn.net/JS072110/article/details/44855565 [未完持续…]]]></content>
      <categories>
        <category>unix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++对象在空间中的布局]]></title>
    <url>%2F2018%2F11%2F20%2FC%2B%2B%2FC%2B%2BObject-Layout%2F</url>
    <content type="text"><![CDATA[C++空类空间 C中的struct空结构体 12struct SEmpty&#123;&#125;; //size of SEmpty is 0;struct SEmpty sEmpty; //size of sEmpty is 0; C++中的class与struct空类 12class CEmpty&#123;&#125;; //size of CEmpty is 1struct SEmpty&#123;&#125;; //size of SEmpty is 1 这是因为C++标准中不允许对象的大小为0，所以用一个字节来区分空类，使得C++类在实例化时得以在内存中配置唯一的地址，但子类继承空类并不会把该字节长度加入子类中： 123class CDeriveE1:public CEmpty &#123; &#125;; //size of CDeriveE1 is 1class CDeriveE2:public CEmpty &#123;public: int a; &#125;; //size of CDeriveE2 is 4 (32 bit machine -m32)class CDeriveE3:public CEmpty &#123;public: int fun()&#123;&#125; ; &#125;; //size of CDeriveE3 is 1 (32 bit machine -m32),成员函数不占空间 CDeriveE2中有成员变量，并且该成员变量可以在类实例化时可以分配内存唯一地址，这样，那个一字节的空间会被有些编译器(现在用的g++)替换成该成员变量的空间. C++数据类空间 单个数据类 12345class CBase0 &#123;public: int baseData0;&#125;; //size of CBase0 is 4 ，baseData0占4字节 继承数据类 12class CDrive0B1: public CBase0 &#123; &#125;; //size of CDrive0B1 is 4class CDrive0B2: public CBase0 &#123; &#125;; //size of CDrive0B2 is 4 很显然，这就是数据继承的意义，子类数据继承父类数据而不用开辟新的空间而导致浪费，那么以下这种情况会怎样。 菱形多继承1class CDriveD0: public CDrive0B1, public CDrive0B2 &#123;&#125;; //size of CDrive0B2 is 8 子类的数据空间被扩大一倍，那么子类到底拥有的是哪里的数据，是父类CDrive0B1和CDrive0B2的数据，还是祖先类CBase0与其中一个父类的数据？通过以下实验观察下：123456CDriveD0 cdrived0;// cdrived0.baseData0 = 1; //编译出错，非静态变量baseData0引起歧义// cdrived0.Base0::baseData0 = 1; //编译出错，非静态变量baseData0引起歧义cdrived0.CDrive0B1::baseData0 = 1;cdrived0.CDrive0B2::baseData0 = 2; 通过gdb断点打印cdrived0信息如下：123(gdb) print cdrived0$1 = &#123;&lt;CDrive0B1&gt; = &#123;&lt;CBase0&gt; = &#123;baseData0 = 1&#125;, &lt;No data fields&gt;&#125;, &lt;CDrive0B2&gt; = &#123;&lt;CBase0&gt; = &#123;baseData0 = 2&#125;, &lt;No data fields&gt;&#125;, &lt;No data fields&gt;&#125;(gdb) 通过该现象说明，对于菱形继承的数据区，子类并没有单独保留祖先类的数据，但父类都继承自祖先类数据，在子类中会对多个父类的数据都保留一份。而如果子类只保留祖先类的数据，两个父类是相对不同的类却在子类中没能被继承数据，这样相当于两个不同的父类共用一套数据，那么在构造该子类进行初始化时，到底该由哪个父类的构造函数进行该数据的初始化就成为了矛盾；如果子类把父类和祖先类的数据都保留下来，那么，对于父类来说，祖先类的数据与父类不同，这也不符合继承规则，这种情况与一个子类非菱形继承三个父类的情况的区分难以辨识（没错这就是强行为编译器辩解）。唯一能够保持语义的是父类双亲各自保留数据，祖先类数据由双亲各自表现。 虚函数表 有无virtual关键字的区别 类的大小 继续研究类中有虚继承和类中有虚函数的情况： 12345678910111213141516171819202122232425//基类：class CBase1&#123;public: void func1(void) &#123; cout&lt;&lt;"CBase1::func1"&lt;&lt;endl; &#125;; void base1func1(void) &#123; cout&lt;&lt;"CBase1::base1func1"&lt;&lt;endl; &#125;; virtual void vfunc1(void) &#123; cout&lt;&lt;"CBase1::vfunc1"&lt;&lt;endl; &#125;; virtual void vb1func1(void) &#123; cout&lt;&lt;"CBase1::vb1func1"&lt;&lt;endl; &#125;&#125;; //size of CBase1 is 4 没有virtual的子类单继承时 1class CDeriveE1:public CEmpty &#123; &#125;; //size of CDeriveE1 is 1; 有virtual的子类单继承时12class CVDeriveE1:public virtual CEmpty &#123; &#125;; //size of CVDeriveE1 is 4 (-m32)class CDrive: public CBase1 &#123; &#125;; //size of CDrive is 4 (-m32) 这里分为两种情况，一种是虚继承，即在定义时指定父类派生到子类的方式声明父类为子类的虚类，如CVDeriveE1虚继承CEmpty那样。另一种为普通继承，但继承的父类里面有虚函数，如CDrive继承CBase1那样，这两种方式都会使得子类在原来没有虚表指针的情况下多一个虚表指针，区别在于，一方面，从子类的大小上说，虚继承只是在子类中指定有这么一个指向虚表的指针，如果子类原来就有虚表指针，那么虚继承不会再给子类多分配一个虚表指针的空间，如下定义所示：1class CVDrive: public virtual CBase1 &#123; &#125;; //size of CVDrive is 4 (-m32) 这种情况放在虚继承多个父类也一样，只要其中一个父类有虚函数，，或者所有父类都采用次虚继承方式（即使所有父类都没有虚函数），虚继承方式不会再产生新叠加的虚表指针。 另一方面，从虚继承本身的意义上说，虚继承时的虚函数表指针用于归总父类中相同的虚函数，这种情况常用于菱形继承，但菱形继承也不会对虚继承多分配一个虚表指针空间，这个后面在进行说明（没有虚函数的菱形继承，有虚函数的菱形继承，没有虚函数有虚继承的菱形继承，有虚函数有虚继承的菱形继承的情况）。 有继承多个virtual的基类时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class CBase2&#123;public: void func2(void) &#123; cout&lt;&lt;"CBase2::func2"&lt;&lt;endl; &#125;; void base1func2(void) &#123; cout&lt;&lt;"CBase2::base1func2"&lt;&lt;endl; &#125;; virtual void vfunc2(void) &#123; cout&lt;&lt;"CBase2::vfunc2"&lt;&lt;endl; &#125;;&#125;;class CDrive1B1: public CBase1&#123;public: void func1(void) &#123; cout&lt;&lt;"CDrive1B1::func1"&lt;&lt;endl; &#125;; void cdriveb1func1(void) &#123; cout&lt;&lt;"CDrive1B1::cdriveb1func1"&lt;&lt;endl; &#125;; virtual void vfunc1(void) &#123; cout&lt;&lt;"CDrive1B1::vfunc1"&lt;&lt;endl; &#125;; virtual void v1func1(void) &#123; cout&lt;&lt;"CDrive1B2::v1func1"&lt;&lt;endl; &#125; ;&#125;; //size of CDrive1B1 is 4class CDrive1B2: public CBase1 &#123;public: void func1(void) &#123; cout&lt;&lt;"CDrive1B2::func1"&lt;&lt;endl; &#125;; void cdriveb2func1(void) &#123; cout&lt;&lt;"CDrive1B2::cdriveb2func1"&lt;&lt;endl; &#125;; virtual void vfunc1(void) &#123; cout&lt;&lt;"CDrive1B2::vfunc1"&lt;&lt;endl; &#125; ; virtual void v2func1(void) &#123; cout&lt;&lt;"CDrive1B2::v2func1"&lt;&lt;endl; &#125; ;&#125;; //size of CDrive1B2 is 4class CDriveD1: public CDrive1B1,public CDrive1B2&#123;public: void func1(void) &#123; cout&lt;&lt;"CDriveD1::func1"&lt;&lt;endl; &#125;; void cdrivedfunc1(void) &#123; cout&lt;&lt;"CDriveD1::cdrivedfunc1"&lt;&lt;endl; &#125;; virtual void vfunc1(void) &#123; cout&lt;&lt;"CDriveD1::vfunc1"&lt;&lt;endl; &#125;; virtual void v1func1(void) &#123; cout&lt;&lt;"CDriveD1::v1func1"&lt;&lt;endl; &#125; ; virtual void v2func1(void) &#123; cout&lt;&lt;"CDriveD1::v2func1"&lt;&lt;endl; &#125; ; virtual void vd1func1(void) &#123; cout&lt;&lt;"CDriveD1::vd1func1"&lt;&lt;endl; &#125; ;&#125;; //size of CDriveD1 is 8class CDriveD1E: public CDrive1B1, public virtual CDeriveE1 &#123;public: virtual void vfunc1(void) &#123; cout&lt;&lt;"CDriveD1::vfunc1"&lt;&lt;endl; &#125;;&#125;; //size of CDriveD1E is 4，这里说明虚继承不会在已有虚指针上再多加一个 CDriveD1属于菱形继承，分别从CDrive1B1和CDrive1B2继承了虚表指针，通过以下程序和gdb打印可以看出: 123CDrive1B1 cdrive1b1;CDrive1B2 cdrive1b2;CDriveD1 cdrived ; 123456789101112131415161718192021222324252627282930(gdb) p cdriveb1$2 = &#123; &lt;CBase1&gt; = &#123; _vptr.CBase1 = 0x8049550 &lt;vtable for CDrive1B1+8&gt; &#125;, &lt;No data fields&gt; &#125;(gdb) p cdriveb2$3 = &#123; &lt;CBase1&gt; = &#123; _vptr.CBase1 = 0x804953c &lt;vtable for CDrive1B2+8&gt; &#125;, &lt;No data fields&gt; &#125;(gdb) p cdrived$4 = &#123; &lt;CDrive1B1&gt; = &#123; &lt;CBase1&gt; = &#123; _vptr.CBase1 = 0x80494f8 &lt;vtable for CDriveD1+8&gt; &#125;, &lt;No data fields&gt; &#125;, &lt;CDrive1B2&gt; = &#123; &lt;CBase1&gt; = &#123; _vptr.CBase1 = 0x8049514 &lt;vtable for CDriveD1+36&gt; &#125;, &lt;No data fields&gt; &#125;, &lt;No data fields&gt; &#125; 在cdrived存在两个虚函数表指针，其中分别是从父类CDrive1B1和CDrive1B2获取，这说明对于多继承情况下，子类对象会对每个父类多分配出对应虚函数表指针的空间，所以cdrived的空间大小为两个虚表指针所占空间之和；而父类中的虚函数表指针又是从祖父类中获取。 深入虚函数和虚继承 虚函数的作用 以下摘要自维基百科：12在面向对象程序设计领域，C++、Object Pascal 等语言中有虚函数（英语：virtual function）或虚方法（英语：virtual method）的概念。这种函数或方法可以被子类继承和覆盖，通常使用动态调度实现。这一概念是面向对象程序设计中（运行时）多态的重要组成部分。简言之，虚函数可以给出目标函数的定义，但该目标的具体指向在编译期可能无法确定。在面向对象程序设计中，派生类继承自基类。使用指针或引用访问派生类对象时，指针或引用本身所指向的类型可以是基类而不是派生类。 意思很明显，也就是说虚函数能够提供在子类重写父类方法后，父类指针或引用能够在运行期动态选择运行子类对象的函数。继续上面的类定义，给出对应示例： 单继承无虚函数与有虚函数：123456CDrive1B1 cdrive1b1;CBase1* pbase1;pbase1 = &amp;cdrive1b1;pbase1-&gt;func1(); //输出"CBase1::func1"pbase1-&gt;vfunc1(); //输出"CDrive1B1::vfunc1" gdb显示pbase1和cdrive1b1的内容：1234(gdb) p *pbase1$2 = &#123;_vptr.CBase1 = 0x8049550 &lt;vtable for CDrive1B1+8&gt;&#125;(gdb) p cdrive1b1$3 = &#123;&lt;CBase1&gt; = &#123;_vptr.CBase1 = 0x8049550 &lt;vtable for CDrive1B1+8&gt;&#125;, &lt;No data fields&gt;&#125; gdb显示的pbase1和cdrive1b1内容只是虚表指针，还需要虚表指针内更深层次的信息,在此之前，先确定虚表指针在对象中存储的位置，由于对象cdrive1b1及其父类没有数据成员，为了充分验证，新追加数据类如下(要补图呀，补CDrive1B3的关系图！)：12345678910111213141516171819202122232425class CDrive1B3: public CBase1 &#123;public: void func1(void) &#123; cout&lt;&lt;"CDrive1B3::func1"&lt;&lt;endl; &#125;; void cdriveb2func1(void) &#123; cout&lt;&lt;"CDrive1B3::cdriveb2func1"&lt;&lt;endl; &#125;; virtual void vfunc1(void) &#123; cout&lt;&lt;"CDrive1B3::vfunc1"&lt;&lt;endl; &#125; ; virtual void v2func1(void) &#123; cout&lt;&lt;"CDrive1B3::v2func1"&lt;&lt;endl; &#125; ; int cdriveData;&#125;; //size of CDrive1B3 is 8 运行程序12345678// CDrive1B1 cdrive1b1;CDrive1B3 cdrive1b3;CBase1* pbase1;// pbase1 = &amp;cdrive1b1;pbase1 = &amp;cdrive1b3;pbase1-&gt;func1(); //输出"CBase1::func1"pbase1-&gt;vfunc1(); //输出"CDrive1B3::vfunc1" gdb 打印cdrive1b3对象的内容和虚函数表指针1234(gdb) p cdrive1b3$1 = &#123;&lt;CBase1&gt; = &#123;_vptr.CBase1 = 0x80496b8 &lt;vtable for CDrive1B3+8&gt;&#125;, cdriveData = 1&#125;(gdb) p *pbase1$2 = &#123;_vptr.CBase1 = 0x80496b8 &lt;vtable for CDrive1B3+8&gt;&#125; 继续打印cdrive1b3存储的信息12345678(gdb) p/x (&amp;((int)cdrive1b3))$3 = 0xffffce0c(gdb) p/x (&amp;((int)cdrive1b3))+1$4 = 0xffffce10(gdb) p/x *((&amp;((int)cdrive1b3))+0)$5 = 0x80496b8(gdb) p/x *((&amp;((int)cdrive1b3))+1)$6 = 0x1 由此可知，cdrive1b3存放的第一个数据是虚表指针（值为0x8049604），第二个数据是数据成员cdriveData的值（值为0x01），也就是说，虚表指正存在对象的前面的位置中，至少目前g++是这样处理虚表指针的位置。那么，虚表指针0x80496b8指向的内容存放的是什么？继续打印虚表指针指向的内容：12345678(gdb) p (long*)*(long*)0x80496b8$7 = (long *) 0x8048ec6 &lt;CDrive1B3::vfunc1()&gt;(gdb) p (long*)*((long*)0x80496b8 + 1)$8 = (long *) 0x8048d38 &lt;CBase1::vb1func1()&gt;(gdb) p (long*)*((long*)0x80496b8 + 2)$9 = (long *) 0x8048ef6 &lt;CDrive1B3::v2func1()&gt;(gdb) p (long*)*((long*)0x80496b8 + 3)$10 = (long *) 0x0 继续换一种方式确定对象中虚函数的存储位置：123456(gdb) p cdrive1b3.vfunc1$19 = &#123;void (CDrive1B3 * const)&#125; 0x8048ec6 &lt;CDrive1B3::vfunc1()&gt;(gdb) p cdrive1b3.vb1func1$20 = &#123;void (CBase1 * const)&#125; 0x8048d38 &lt;CBase1::vb1func1()&gt;(gdb) p cdrive1b3.v2func1$21 = &#123;void (CDrive1B3 * const)&#125; 0x8048ef6 &lt;CDrive1B3::v2func1()&gt; cdrive1b3虚表指针存放的是该类中所有虚函数的指针，如图所示（要补图呀）。从结果可以看出，如果子类重写父类虚函数，那么子类对象调用的是子类的虚函数，同样，即使父类指针指向子类对象，父类指针也仍然会用子类重写的虚函数。 多继承中的虚函数 接下来观察继承多个有虚函数的父类的情况，先定义一个简单多继承非多次继承的子类，分析之： 123class CDriveB1B2: public CBase1,public CBase2&#123;&#125;;//size of CDriveB1B2 is 8 该多继承类结构如下图所示补图呀 构造该对象，并用gdb打印该对象的内容：1CDriveB1B2 cdriveb1b2; 123456789101112131415(gdb) p cdriveb1b2$1 = &#123;&lt;CBase1&gt; = &#123;_vptr.CBase1 = 0x804953c &lt;vtable for CDriveB1B2+8&gt;&#125;, &lt;CBase2&gt; = &#123; _vptr.CBase2 = 0x804954c &lt;vtable for CDriveB1B2+24&gt;&#125;, &lt;No data fields&gt;&#125;(gdb) p (long*)*((long*)0x804953c + 1)$2 = (long *) 0x8048d38 &lt;CBase1::vb1func1()&gt;(gdb) p (long*)*((long*)0x804953c + 0)$3 = (long *) 0x8048d08 &lt;CBase1::vfunc1()&gt;(gdb) p (long*)*((long*)0x804953c + 1)$4 = (long *) 0x8048d38 &lt;CBase1::vb1func1()&gt;(gdb) p (long*)*((long*)0x804953c + 2)$5 = (long *) 0xfffffffc(gdb) p (long*)*((long*)0x804954c + 0)$6 = (long *) 0x8048d68 &lt;CBase2::vfunc2()&gt;(gdb) p (long*)*((long*)0x804954c + 1)$7 = (long *) 0x0 由此可以看出，cdriveb1b2有两个虚表指针，占据cdriveb1b2的存储空间，这两个虚表指针分别继承自两个父类CBase1和CBase2的虚函数表，由此可知，CDriveB1B2的存储关系如下补图呀 再来分析多父类有多次继承的子类，先定义一个1234class CDriveD1S: public CDrive1B1, public CBase2&#123;&#125;; //size of CDriveD1S is 8 1CDriveD1S cdrive1s; // CDriveD1S类的继承关系如下图所示补图 那么实际上CDriveD1S的存储空间及其虚表内容是怎样，继续用gdb的方式与上面同样的方法将cdrive1s的内容打印出来：123456789101112131415161718192021222324252627282930#对象存储的内容(gdb) p cdrive1s$1 = &#123; &lt;CDrive1B1&gt; = &#123; &lt;CBase1&gt; = &#123; _vptr.CBase1 = 0x80494bc &lt;vtable for CDriveD1S+8&gt; &#125;, &lt;No data fields&gt; &#125;, &lt;CBase2&gt; = &#123; _vptr.CBase2 = 0x80494d0 &lt;vtable for CDriveD1S+28&gt; &#125;, &lt;No data fields&gt; &#125;#第一个虚表指针的内容(gdb) p (long*)*((long*)0x80494bc + 0)$5 = (long *) 0x8048df8 &lt;CDrive1B1::vfunc1()&gt;(gdb) p (long*)*((long*)0x80494bc + 1)$6 = (long *) 0x8048d38 &lt;CBase1::vb1func1()&gt;(gdb) p (long*)*((long*)0x80494bc + 2)$7 = (long *) 0x8048e28 &lt;CDrive1B1::v1func1()&gt;(gdb) p (long*)*((long*)0x80494bc + 3)$8 = (long *) 0xfffffffc#第二个虚表指针的内容(gdb) p (long*)*((long*)0x80494d0 + 0)$9 = (long *) 0x8048d68 &lt;CBase2::vfunc2()&gt;(gdb) p (long*)*((long*)0x80494d0 + 1)$10 = (long *) 0x0 虽然cdrive1s打印的虚函数内容多一些，但虚表结构是与cdriveb1b2一致。 菱形继承中的虚函数 继续研究CDriveD1类的继承关系，如图所示给图呀： 同样用gdb打印虚表信息： 12345678910111213141516171819202122232425262728293031323334353637383940# cdrived中的结构(gdb) p cdrived$12 = &#123; &lt;CDrive1B1&gt; = &#123; &lt;CBase1&gt; = &#123; _vptr.CBase1 = 0x80494f8 &lt;vtable for CDriveD1+8&gt; &#125;, &lt;No data fields&gt; &#125;, &lt;CDrive1B2&gt; = &#123; &lt;CBase1&gt; = &#123; vptr.CBase1 = 0x8049514 &lt;vtable for CDriveD1+36&gt; &#125;, &lt;No data fields&gt; &#125;, &lt;No data fields&gt; &#125;# cdrived第一张虚表（从CDrive1B1）(gdb) p (long*)*((long*)0x80494f8 + 0)$14 = (long *) 0x8048f18 &lt;CDriveD1::vfunc1()&gt;(gdb) p (long*)*((long*)0x80494f8 + 1)$15 = (long *) 0x8048d38 &lt;CBase1::vb1func1()&gt;(gdb) p (long*)*((long*)0x80494f8 + 2)$16 = (long *) 0x8048f4e &lt;CDriveD1::v1func1()&gt;(gdb) p (long*)*((long*)0x80494f8 + 3)$17 = (long *) 0x8048f7e &lt;CDriveD1::v2func1()&gt;(gdb) p (long*)*((long*)0x80494f8 + 4)$18 = (long *) 0x8048fb4 &lt;CDriveD1::vd1func1()&gt;(gdb) p (long*)*((long*)0x80494f8 + 5)$19 = (long *) 0xfffffffc# cdrived第二张虚表（从CDrive1B2）(gdb) p (long*)*((long*)0x8049514 + 0)$20 = (long *) 0x8048f47 &lt;non-virtual thunk to CDriveD1::vfunc1()&gt;(gdb) p (long*)*((long*)0x8049514 + 1)$21 = (long *) 0x8048d38 &lt;CBase1::vb1func1()&gt;(gdb) p (long*)*((long*)0x8049514 + 2)$22 = (long *) 0x8048fad &lt;non-virtual thunk to CDriveD1::v2func1()&gt;(gdb) p (long*)*((long*)0x8049514 + 3)$23 = (long *) 0x0 菱形继承的虚函数表与普通多继承的数据一致，但是，仔细观察可以发现，这两个分别从CDrive1B1和CDrive1B2继承而来的虚表有重叠部分 —— 祖先类的虚函数CBase1::vb1func1()被重复放在这两个父类的虚函数表中了。那么如果子类CDriveD1要调用祖先类的vb1func1会怎样？12cdrived.vb1func1(); //编译出错，提示函数‘vb1func1’有歧义cdrived.CBase1::vb1func1(); //编译出错，提示‘CBase1’对‘CDriveD1’有歧义 此时编译会出错，出错的原因是这两个父类在各自的虚表中都保留一份CBase1::vb1func1()的函数指针，虽然内容一样，但实际运行时程序无法选择到底用哪一边的虚函数指针的偏置来索引对应的函数（是应该用CDrive1B1的虚表指针索引呢还是应该用CDrive1B2的虚表指针索引），这就引发歧义；即使用作用域限定也不行，这个不懂这个等了解作用域运算的作用后再细研究。那有什么方法能够使得子类CDriveD1能够调用祖先类CBase1的vb1func1函数呢？下面的虚继承可以完成这项艰巨的任务。 虚继承的作用 紧接上面的问题，为了做对比，保留原有的函数结构，只在父类用虚继承的方式继承祖父类CBase1，新的类定义如下添图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class CVDrive1B1: public virtual CBase1&#123;public: void func1(void) &#123; cout&lt;&lt;"CVDrive1B1::func1"&lt;&lt;endl; &#125;; void cdriveb1func1(void) &#123; cout&lt;&lt;"CVDrive1B1::cdriveb1func1"&lt;&lt;endl; &#125;; virtual void vfunc1(void) &#123; cout&lt;&lt;"CVDrive1B1::vfunc1"&lt;&lt;endl; &#125;; virtual void v1func1(void) &#123; cout&lt;&lt;"CVDrive1B1::v1func1"&lt;&lt;endl; &#125; ;&#125;; //size of CVDrive1B1 is 4class CVDrive1B2: public virtual CBase1 &#123;public: void func1(void) &#123; cout&lt;&lt;"CVDrive1B2::func1"&lt;&lt;endl; &#125;; void cdriveb2func1(void) &#123; cout&lt;&lt;"CVDrive1B2::cdriveb2func1"&lt;&lt;endl; &#125;; virtual void vfunc1(void) &#123; cout&lt;&lt;"CVDrive1B2::vfunc1"&lt;&lt;endl; &#125; ; virtual void v2func1(void) &#123; cout&lt;&lt;"CVDrive1B2::v2func1"&lt;&lt;endl; &#125; ;&#125;; //size of CVDrive1B2 is 4class CVDriveD1: public CVDrive1B1,public CVDrive1B2&#123;public: void func1(void) &#123; cout&lt;&lt;"CVDriveD1::func1"&lt;&lt;endl; &#125;; void cdrivedfunc1(void) &#123; cout&lt;&lt;"CVDriveD1::cdrivedfunc1"&lt;&lt;endl; &#125;; virtual void vfunc1(void) &#123; cout&lt;&lt;"CVDriveD1::vfunc1"&lt;&lt;endl; &#125;; virtual void v1func1(void) &#123; cout&lt;&lt;"CVDriveD1::v1func1"&lt;&lt;endl; &#125; ; virtual void v2func1(void) &#123; cout&lt;&lt;"CVDriveD1::v2func1"&lt;&lt;endl; &#125; ; virtual void vd1func1(void) &#123; cout&lt;&lt;"CVDriveD1::vd1func1"&lt;&lt;endl; &#125; ;&#125;; //size of CVDriveD1 is 8 接下来，尝试CVDriveD1对象能不能调用祖父类CBase1中的函数vb1func1()1234CVDriveD1 cvdrived;cvdrived.vb1func1(); //输出"CBase1::vb1func1"cvdrived.CBase1::vb1func1(); //输出"CBase1::vb1func1"cvdrived.base1func1(); //输出"CBase1::vbase1func1" 由此可以看出，虚继承可以使得菱形继承中的子类能够访问祖先类的函数（包括虚函数和非虚函数，非虚函数后面为何能够调用现在还不知道如何解释）。为什么虚继承能够有如此功能，还是老方法，用gdb打印虚表的关系：1234567891011121314(gdb) p cvdrived$1 = &#123; &lt;CVDrive1B1&gt; = &#123; &lt;CBase1&gt; = &#123; _vptr.CBase1 = 0x8049804 &lt;vtable for CVDriveD1+20&gt; &#125;, &lt;No data fields&gt;&#125;, &lt;CVDrive1B2&gt; = &#123; &lt;No data fields&gt; &#125;, &lt;No data fields&gt; &#125;(gdb) p sizeof(cvdrived)$2 = 8 这个很奇怪，cvdrived的大小为8，而打印出的虚表指针只有一个，而且只有其中第一个父类CVDrive1B1有虚表指针，第二个父类CVDrive1B2没有，cvdrived也没有其他数据成员。那么cvdrived的另外一个空间存放的是什么数据？继续调试： 12345678(gdb) p/x (&amp;((int)cvdrived))$3 = 0xffffce24(gdb) p/x (&amp;((int)cvdrived))+1$4 = 0xffffce28(gdb) p/x *((&amp;((int)cvdrived))+0)$5 = 0x8049804(gdb) p/x *((&amp;((int)cvdrived))+1)$6 = 0x804982c cvdrived的第二个存储数据值0x804982c与已知的虚函数表指针值0x8049804相差不大，由此猜测0x804982c也是指针，接下来，按常规调试打印这指针所指向的内容：123456789101112131415161718#打印虚表（0x8049804）(gdb) p (long*)*((long*)0x8049804 + 0)$10 = (long *) 0x804912c &lt;CVDriveD1::vfunc1()&gt;(gdb) p (long*)*((long*)0x8049804 + 1)$11 = (long *) 0x8048d74 &lt;CBase1::vb1func1()&gt;(gdb) p (long*)*((long*)0x8049804 + 2)$12 = (long *) 0x8049172 &lt;CVDriveD1::v1func1()&gt;(gdb) p (long*)*((long*)0x8049804 + 3)$13 = (long *) 0x80491a2 &lt;CVDriveD1::v2func1()&gt;(gdb) p (long*)*((long*)0x8049804 + 4)$14 = (long *) 0x80491d8 &lt;CVDriveD1::vd1func1()&gt;(gdb) p (long*)*((long*)0x8049804 + 5)$15 = (long *) 0xfffffffc#第二个指针（0x804982c）(gdb) p (long*)*((long*)0x804982c + 0)$19 = (long *) 0x804916a &lt;non-virtual thunk to CVDriveD1::vfunc1()&gt;(gdb) p (long*)*((long*)0x804982c + 1)$20 = (long *) 0x0 看起来虚继承后的虚函数表的内容被”整理“过，该虚表中只存在被子类重写和没被子类重写的虚函数，并没有像非虚继承那样重复保存两份相同的虚函数指针在不同的虚表上，仔细观察虽然有两个CVDriveD1::vfunc1()函数，但其函数地址不同（分别是0x804912c和0x804916a），而且已经指明其中一个为非虚函数（）那么CVDriveD1存储的第二个指针的意义是什么，跪求大神们赐教？ 由此，可以得出CVDriveD1对象的虚函数表结构图图图图！ 多态作为参数的限制 在非指针的情况下，子类对父类变量的数据复制往往会发生截断，但类中的函数并不占空间，那么在子类对父类变量的复制过程中父类如何选择使用函数。 1. 非指针变量的父子类之间的复制不能多态 比如有如下定义： 123456789101112131415161718class Book&#123;public: virtual ~Book()&#123;cout&lt;&lt;"this is book destruction."&lt;&lt;endl;&#125;; virtual void reading()&#123;cout&lt;&lt;"reading a book"&lt;&lt;endl;&#125;protected: uint32_t pageNum; char* bookName;&#125;;class AlgorithmBook:public Book&#123;public: virtual ~AlgorithmBook()&#123;cout&lt;&lt;"this is algorithm book destruction"&lt;&lt;endl;&#125;; virtual void reading()&#123;cout&lt;&lt;"reading an algorithm book"&lt;&lt;endl;&#125;protected: uint32_t tuiFunCnt;&#125;; 尝试运行下面程序： 123456AlgorithmBook algoBook;Book book = algoBook; //父类局部Book* pbook = &amp;algoBook; //父类指针algoBook.reading(); //使用AlgorithmBook::readingbook.reading(); //使用Book::readingpbook-&gt;reading(); //使用AlgorithmBook::reading 可见父类的非指针变量(book)并没有调用到子类的方法(reading)，为什么会这样，考虑下以下两种情形 假设父类非指针变量可以调用子类多态化的函数 也就是book只占有Book所存储的空间的情况下能够调用子类的reading，这样在现有的函数功能看起来没问题（只是一个普通打印信息），但如果子类的reading如果定义为如下的函数: 12345void AlgorithmBook::reading()&#123; cout&lt;&lt;"reading an algorithm book"&lt;&lt;endl; cout&lt;&lt;"lesson count is "&lt;&lt;this-&gt;nTuiFunCnt&lt;&lt;endl;&#125; 这样就会导致book的确需要增加子类AlgorithmBook的nTuiFunCnt成员存放空间，这样显然不成立book只占用Book的空间大小的情况，另外无论如何重载复制构造函数或赋值运算符，基类(Book)都没有子类的那个成员，所以这种既不想浪费空间又要调用子类的矛盾成立。 假设父类非指针变量能够全盘复制子类中的所有成员 既然book在这种情况下需要子类AlgorithmBook，那么全盘复制不就行了。但是，这实际导致了空间浪费，如果其他子类（比如有一个子类LiteratureBook的对象）也要复制到非指针变量中，那么，在定义基类非指针变量的时候就要分配所有的子类空间，当子类繁多时，基类以此扩大空间的定义，空间占用相当大；而实际上，在单纯地想用基类运作时用不到到这些不需要的资源的可能性很多。 当然像这种父类非指针变量给子类非指针变量赋值或初始化复制也是不可以的，还有子类指针指向父类地址的行为也是会不被允许： 12345678Book book;AlgorithmBook algoBook1 = book; //编译出错，提示不适配的转换AlgorithmBook algoBook2;AlgorithmBook* palgoBook;algoBook2 = book; //编译出错，提示不适配的转换palgoBook = &amp;book; //编译出错，提示指针类型不适配palgoBook = dynamic_cast&lt;AlgorithmBook*&gt;(&amp;book); //编译警告，dynamic_cast的转换将不会成功。 编译器这样处理的原因是，当父类对象要对子类对象赋值或复制时，对于那些子类有而父类没有的子类成员的处理是未知的（保持原样不就行了？这个坑待填）。而子类指针指向父类时，对于后续继续对该子类指针的使用很有可能使用到父类没有的成员，这样导致的结果也是未知的有危险的。 2. 父子类作为函数也不能多态 尝试将变量作为普通变量，引用，指针传入函数： 1234567int test(Book book, Book&amp; qbook, Book* pbook)&#123; book.reading(); qbook.reading(); pbook-&gt;reading(); return 1;&#125; 运行程序： 12AlgorithmBook algoBook;test(algoBook,algoBook,&amp;algoBook); 这时候，test函数实际的运行情况是这样： 1234567test((Book )algoBook, (AlgorithmBook&amp; )algoBook, (AlgorithmBook* )&amp;algoBook)&#123; ((Book )algoBook).reading(); //使用Book::reading algoBook.reading(); //使用AlgorithmBook::reading algoBook-&gt;reading(); //使用AlgorithmBook::reading return 1;&#125; 这种函数普通参数不能多态的规则也是遵循上述一样的规则 —— 空间最小化，否则，在多重继承和多重函数调用势必没有足够的资源（堆栈）能够支持其运行。 参考 《深度探索C++对象模型》 https://blog.csdn.net/SuLiJuan66/article/details/48897867 http://blog.51cto.com/haoel/124595]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
</search>
